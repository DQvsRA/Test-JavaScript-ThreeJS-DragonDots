THREE.OBJLoader=function(e){this.manager=void 0!==e?e:THREE.DefaultLoadingManager},THREE.OBJLoader.prototype={constructor:THREE.OBJLoader,load:function(e,r){var t=this,a=new THREE.XHRLoader(t.manager);a.setCrossOrigin(this.crossOrigin),a.load(e,function(e){r(t.parse(e))})},parse:function(e){function r(e,r,t){return new THREE.Vector3(e,r,t)}function t(e,r){return new THREE.Vector2(e,r)}function a(e,r,t,a){return new THREE.Face3(e,r,t,a)}e=e.replace(/\ \\\r\n/g,"");var s="/f$1$2$4\n/f$2$3$4";e=e.replace(/f( +\d+)( +\d+)( +\d+)( +\d+)/g,s),e=e.replace(/f( +\d+\/\d+)( +\d+\/\d+)( +\d+\/\d+)( +\d+\/\d+)/g,s),e=e.replace(/f( +\d+\/\d+\/\d+)( +\d+\/\d+\/\d+)( +\d+\/\d+\/\d+)( +\d+\/\d+\/\d+)/g,s),e=e.replace(/f( +\d+\/\/\d+)( +\d+\/\/\d+)( +\d+\/\/\d+)( +\d+\/\/\d+)/g,s);var n,d,p,o=new THREE.Object3D;/^o /gm.test(e)===!1&&(n=new THREE.Geometry,d=new THREE.MeshLambertMaterial,p=new THREE.Mesh(n,d),o.add(p));for(var c=[],l=0,u=[],i=[],E=/v( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/,h=/vn( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/,f=/vt( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/,I=/f( +\d+)( +\d+)( +\d+)/,g=/f( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))/,m=/f( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))/,v=/f( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))/,H=e.split("\n"),R=0;R<H.length;R++){var T=H[R];T=T.trim();var w;0!==T.length&&"#"!==T.charAt(0)&&(null!==(w=E.exec(T))?c.push(r(parseFloat(w[1]),parseFloat(w[2]),parseFloat(w[3]))):null!==(w=h.exec(T))?u.push(r(parseFloat(w[1]),parseFloat(w[2]),parseFloat(w[3]))):null!==(w=f.exec(T))?i.push(t(parseFloat(w[1]),parseFloat(w[2]))):null!==(w=I.exec(T))?(n.vertices.push(c[parseInt(w[1])-1],c[parseInt(w[2])-1],c[parseInt(w[3])-1]),n.faces.push(a(l++,l++,l++))):null!==(w=g.exec(T))?(n.vertices.push(c[parseInt(w[2])-1],c[parseInt(w[5])-1],c[parseInt(w[8])-1]),n.faces.push(a(l++,l++,l++)),n.faceVertexUvs[0].push([i[parseInt(w[3])-1],i[parseInt(w[6])-1],i[parseInt(w[9])-1]])):null!==(w=m.exec(T))?(n.vertices.push(c[parseInt(w[2])-1],c[parseInt(w[6])-1],c[parseInt(w[10])-1]),n.faces.push(a(l++,l++,l++,[u[parseInt(w[4])-1],u[parseInt(w[8])-1],u[parseInt(w[12])-1]])),n.faceVertexUvs[0].push([i[parseInt(w[3])-1],i[parseInt(w[7])-1],i[parseInt(w[11])-1]])):null!==(w=v.exec(T))?(n.vertices.push(c[parseInt(w[2])-1],c[parseInt(w[5])-1],c[parseInt(w[8])-1]),n.faces.push(a(l++,l++,l++,[u[parseInt(w[3])-1],u[parseInt(w[6])-1],u[parseInt(w[9])-1]]))):/^o /.test(T)?(n=new THREE.Geometry,d=new THREE.MeshLambertMaterial,p=new THREE.Mesh(n,d),p.name=T.substring(2).trim(),o.add(p),l=0):/^g /.test(T)||(/^usemtl /.test(T)?d.name=T.substring(7).trim():/^mtllib /.test(T)||/^s /.test(T)))}for(var R=0,F=o.children.length;F>R;R++){var n=o.children[R].geometry;n.computeCentroids(),n.computeFaceNormals(),n.computeBoundingSphere()}return o}};